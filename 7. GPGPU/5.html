<body></body>
<script id="x-fragment" type="x-shader">
  precision mediump float;

  const vec3 lightDir = vec3(0.577350269, 0.577350269, -0.577350269);
  varying vec3 vPosition;
  uniform vec3 cameraPos;
  uniform vec3 sphere1Center;
  uniform vec3 sphere2Center;
  uniform vec3 sphere3Center;

  bool intersectSphere(vec3 center, vec3 lStart, vec3 lDir,
                       out float dist) {
    vec3 c = center - lStart;
    float b = dot(lDir, c);
    float d = b*b - dot(c, c) + 1.0;
    if (d < 0.0) {
      dist = 10000.0;
      return false;
    }

    dist = b - sqrt(d);
    if (dist < 0.0) {
      dist = 10000.0;
      return false;
    }

    return true;
  }

  vec3 lightAt(vec3 N, vec3 V, vec3 color) {
    vec3 L = lightDir;
    vec3 R = reflect(-L, N);

    float c = 0.3 + 0.4 * pow(max(dot(R, V), 0.0), 30.0) + 0.7 * dot(L, N);

    if (c > 1.0) {
      return mix(color, vec3(1.6, 1.6, 1.6), c - 1.0);
    }

    return c * color;
  }

  bool intersectWorld(vec3 lStart, vec3 lDir, out vec3 pos,
                      out vec3 normal, out vec3 color) {
    float d1, d2, d3;
    bool h1, h2, h3;

    h1 = intersectSphere(sphere1Center, lStart, lDir, d1);
    h2 = intersectSphere(sphere2Center, lStart, lDir, d2);
    h3 = intersectSphere(sphere3Center, lStart, lDir, d3);

    if (h1 && d1 < d2 && d1 < d3) {
      pos = lStart + d1 * lDir;
      normal = pos - sphere1Center;
      color = vec3(0.0, 0.0, 0.9);
    }
    else if (h2 && d2 < d3) {
      pos = lStart + d2 * lDir;
      normal = pos - sphere2Center;
      color = vec3(0.9, 0.0, 0.0);
    }
    else if (h3) {
      pos = lStart + d3 * lDir;
      normal = pos - sphere3Center;
      color = vec3(0.0, 0.9, 0.0);
    }
    else if (lDir.y < -0.01) {
      pos = lStart + ((lStart.y + 2.7) / -lDir.y) * lDir;
      if (pos.x*pos.x + pos.z*pos.z > 30.0) {
        return false;
      }
      normal = vec3(0.0, 1.0, 0.0);
      if (fract(pos.x / 5.0) > 0.5 == fract(pos.z / 5.0) > 0.5) {
        color = vec3(1.0);
      }
      else {
        color = vec3(0.0);
      }
    }
    else {
     return false;
    }

    return true;
  }

  void main(void)
  {
    vec3 cameraDir = normalize(vPosition - cameraPos);

    vec3 p1, norm, p2;
    vec3 col, colT, colM, col3;
    if (intersectWorld(cameraPos, cameraDir, p1,
                       norm, colT)) {
      col = lightAt(norm, -cameraDir, colT);
      colM = (colT + vec3(0.7)) / 1.7;
      cameraDir = reflect(cameraDir, norm);
      if (intersectWorld(p1, cameraDir, p2, norm, colT)) {
        col += lightAt(norm, -cameraDir, colT) * colM;
        colM *= (colT + vec3(0.7)) / 1.7;
        cameraDir = reflect(cameraDir, norm);
        if (intersectWorld(p2, cameraDir, p1, norm, colT)) {
          col += lightAt(norm, -cameraDir, colT) * colM;
        }
      }

      gl_FragColor = vec4(col, 1.0);
    }
    else {
      gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
  }
</script>
<script id="x-vertex" type="x-shader">
  attribute vec2 aVertexPosition;
  attribute vec3 aPlotPosition;

  varying vec3 vPosition;

  void main(void)
  {
    gl_Position = vec4(aVertexPosition, 0.0, 1.0);
    vPosition = aPlotPosition;
 }
</script>

<script>

    var canvas  = document.createElement("canvas"); document.body.appendChild(canvas);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    var ratio = canvas.width / canvas.height;
    var gl = canvas.getContext("webgl");

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, document.getElementById("x-vertex").text);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, document.getElementById("x-fragment").text);
    gl.compileShader(fragmentShader);
    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.useProgram(shaderProgram);

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1.0,  1.0, -1.0,  1.0, 1.0, -1.0, -1.0, -1.0,]), gl.STATIC_DRAW);
    gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aVertexPosition"), 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aVertexPosition"));

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "aPlotPosition"), 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "aPlotPosition"));

    var cameraPos       = gl.getUniformLocation(shaderProgram, "cameraPos");
    var sphere1Center   = gl.getUniformLocation(shaderProgram, "sphere1Center");
    var sphere2Center   = gl.getUniformLocation(shaderProgram, "sphere2Center");
    var sphere3Center   = gl.getUniformLocation(shaderProgram, "sphere3Center");
    var t = 0;

    function crossProd(v1, v2) {
        return {
            x: v1.y * v2.z - v2.y * v1.z,
            y: v1.z * v2.x - v2.z * v1.x,
            z: v1.x * v2.y - v2.x * v1.y
        };
    }

    function normalize(v) {
        l = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
        return {
            x : v.x / l,
            y : v.y / l,
            z : v.z / l
        };
    }

    function vectAdd(v1, v2) {
        return {
            x : v1.x + v2.x,
            y : v1.y + v2.y,
            z : v1.z + v2.z
        };
    }

    function vectSub(v1, v2) {
        return {
            x : v1.x - v2.x,
            y : v1.y - v2.y,
            z : v1.z - v2.z
        };
    }

    function vectMul(v, l) {
        return {
            x : v.x * l,
            y : v.y * l,
            z : v.z * l
        };
    }

    function pushVec(v, arr) {
        arr.push(v.x, v.y, v.z);
    }


    function drawScene() {
        t += .01;
        x1 = Math.sin(t * 1.1)      * 1.9;
        y1 = Math.cos(t * 1.3)      * 1.9;
        z1 = Math.sin(t + Math.PI/3)* 1.9;
        x2 = Math.cos(t * 1.2)      * 1.9;
        y2 = Math.sin(t * 1.4)      * 1.9;
        z2 = Math.sin(t * 1.25 - Math.PI/3) * 1.9;
        x3 = Math.cos(t * 1.15)     * 1.9;
        y3 = Math.sin(t * 1.37)     * 1.9;
        z3 = Math.sin(t * 1.27)     * 1.9;

        cameraFrom = {
            x : Math.sin(t * 0.3)   * 18,
            y : Math.sin(t * 0.2)   * 10 + 10,
            z : Math.cos(t * 0.4)   * 18
        };
        cameraTo = {
            x : 0, y : 0, z : 0
        };

        cameraPersp = 6;

        up = { x: 0, y: 1, z: 0 };

        cameraDir   = normalize(vectSub(cameraTo, cameraFrom));
        cameraLeft  = normalize(crossProd(cameraDir, up));
        cameraUp    = normalize(crossProd(cameraLeft, cameraDir));
        cameraCenter= vectAdd( cameraFrom, vectMul(cameraDir, cameraPersp) );                       // cameraFrom + cameraDir * cameraPersp
        cameraTopLeft  = vectAdd( vectAdd(cameraCenter, cameraUp), vectMul(cameraLeft, ratio) );    // cameraCenter + cameraUp + cameraLeft * ratio
        cameraBotLeft  = vectAdd( vectSub(cameraCenter, cameraUp), vectMul(cameraLeft, ratio) );    // cameraCenter - cameraUp + cameraLeft * ratio
        cameraTopRight = vectSub( vectAdd(cameraCenter, cameraUp), vectMul(cameraLeft, ratio) );    // cameraCenter + cameraUp - cameraLeft * ratio
        cameraBotRight = vectSub( vectSub(cameraCenter, cameraUp), vectMul(cameraLeft, ratio) );    // cameraCenter - cameraUp - cameraLeft * ratio

        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            cameraTopRight.x,   cameraTopRight.y,   cameraTopRight.z,
            cameraTopLeft.x,    cameraTopLeft.y,    cameraTopLeft.z,
            cameraBotRight.x,   cameraBotRight.y,   cameraBotRight.z,
            cameraBotLeft.x,    cameraBotLeft.y,    cameraBotLeft.z
        ]), gl.STATIC_DRAW);

        gl.uniform3f(cameraPos, cameraFrom.x, cameraFrom.y, cameraFrom.z);
        gl.uniform3f(sphere1Center, x1, y1, z1);
        gl.uniform3f(sphere2Center, x2, y2, z2);
        gl.uniform3f(sphere3Center, x3, y3, z3);

        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        window.requestAnimationFrame(drawScene);
    }
    drawScene();
</script>