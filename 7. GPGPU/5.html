<!--
What is aPlotPosition?
 -->
<body></body>
<script id="x-fragment" type="x-shader">
    precision mediump float;
       vec3 lightDir   = 1.07 * normalize(vec3(1.0, 1.0, -1.0));
       vec3 blandColour= 1.05 * normalize(vec3(1.0, 1.0, 1.0));
       float ambience  = 0.3;
       float diffussion= 0.3;
       float shinyness = 0.5;
    varying vec3 vPosition;
    varying vec3 cameraPostion;
    varying vec4 spherePos[10];
    varying vec3 sphereCol[10];

    bool intersectSphere(vec4 sphere, vec3 rayStart, vec3 rayDirection, out float distance) {
        vec3    c = sphere.xyz - rayStart;
        float   b = dot(rayDirection, c);
        float   d = sphere.w + b * b - dot(c, c);
        if (d < 0.0) {
            distance = 999.0;
            return false;
        }
        distance = b - sqrt(d);
        if (distance < 0.0) {
            distance = 999.0;
            return false;
        }
        return true;

        // vec3    relSpherePos = sphere.xyz - rayStart;
        // float   b = dot(relSpherePos, rayDirection);
        // float   c2 = dot(relSpherePos, relSpherePos);
        // float   a2 = c2 - b*b; // pythag

        // if (a2 > (sphere.w * sphere.w)) {
        //     distance = 10000.0;
        //     return false;
        // }
        // float a = sqrt(a2);
        // distance = b - a;
        // if (distance < 0.0) {
        //     distance = 10000.0;
        //     return false;
        // }

        // return true;
    }

    vec3 lightAt(vec3 instersectNormal, vec3 rayDirection, vec3 color) {
        float visibleLightReflection = dot(reflect(lightDir, instersectNormal), rayDirection);
        if (visibleLightReflection < 0.0) visibleLightReflection = 0.0;
        float saturation = ambience
                + shinyness   * pow(visibleLightReflection, 50.0)
                + diffussion  * dot(lightDir, instersectNormal);
        if (saturation > 1.0){
            float overSaturation = saturation - 1.0;
            return mix(color, 2.0 * blandColour, overSaturation);
        }
        return saturation * color;
    }

    bool intersectWorld(vec3 lStart, inout vec3 rayDirection, out vec3 intersectPosition, inout vec3 endColour, inout vec3 colMultiplier) {
        float d[10], distance;
        vec3 instersectNormal, collisionColor, ballCenter;
        bool ground = false;
        bool h0 = intersectSphere(spherePos[0], lStart, rayDirection, d[0]);
        bool h1 = intersectSphere(spherePos[1], lStart, rayDirection, d[1]);
        bool h2 = intersectSphere(spherePos[2], lStart, rayDirection, d[2]);
        bool h3 = intersectSphere(spherePos[3], lStart, rayDirection, d[3]);
        bool h4 = intersectSphere(spherePos[4], lStart, rayDirection, d[4]);
        bool h5 = intersectSphere(spherePos[5], lStart, rayDirection, d[5]);
        bool h6 = intersectSphere(spherePos[6], lStart, rayDirection, d[6]);
        bool h7 = intersectSphere(spherePos[7], lStart, rayDirection, d[7]);
        bool h8 = intersectSphere(spherePos[8], lStart, rayDirection, d[8]);
        bool h9 = intersectSphere(spherePos[9], lStart, rayDirection, d[9]);

             if (h0 && d[0] < d[9] && d[0] < d[8] && d[0] < d[7] && d[0] < d[6] && d[0] < d[5] && d[0] < d[4] && d[0] < d[3] && d[0] < d[2] && d[0] < d[1]) {distance = d[0]; collisionColor = sphereCol[0]; ballCenter = spherePos[0].xyz;}
        else if (h9 && d[9] < d[8] && d[9] < d[7] && d[9] < d[6] && d[9] < d[5] && d[9] < d[4] && d[9] < d[3] && d[9] < d[2] && d[9] < d[1])                {distance = d[9]; collisionColor = sphereCol[9]; ballCenter = spherePos[9].xyz;}
        else if (h8 && d[8] < d[7] && d[8] < d[6] && d[8] < d[5] && d[8] < d[4] && d[8] < d[3] && d[8] < d[2] && d[8] < d[1])                               {distance = d[8]; collisionColor = sphereCol[8]; ballCenter = spherePos[8].xyz;}
        else if (h7 && d[7] < d[6] && d[7] < d[5] && d[7] < d[4] && d[7] < d[3] && d[7] < d[2] && d[7] < d[1])                                              {distance = d[7]; collisionColor = sphereCol[7]; ballCenter = spherePos[7].xyz;}
        else if (h6 && d[6] < d[5] && d[6] < d[4] && d[6] < d[3] && d[6] < d[2] && d[6] < d[1])                                                             {distance = d[6]; collisionColor = sphereCol[6]; ballCenter = spherePos[6].xyz;}
        else if (h5 && d[5] < d[4] && d[5] < d[3] && d[5] < d[2] && d[5] < d[1])                                                                            {distance = d[5]; collisionColor = sphereCol[5]; ballCenter = spherePos[5].xyz;}
        else if (h4 && d[4] < d[3] && d[4] < d[2] && d[4] < d[1])                                                                                           {distance = d[4]; collisionColor = sphereCol[4]; ballCenter = spherePos[4].xyz;}
        else if (h3 && d[3] < d[2] && d[3] < d[1])                                                                                                          {distance = d[3]; collisionColor = sphereCol[3]; ballCenter = spherePos[3].xyz;}
        else if (h2 && d[2] < d[1])                                                                                                                         {distance = d[2]; collisionColor = sphereCol[2]; ballCenter = spherePos[2].xyz;}
        else if (h1)                                                                                                                                        {distance = d[1]; collisionColor = sphereCol[1]; ballCenter = spherePos[1].xyz;}
        else if (rayDirection.y < 0.0)                                                                                                                      {distance = -lStart.y / rayDirection.y; ground = true;}
        // Our eye and objects are above the floor. Hence can't possibly intersect if ray going upwards
        else return false;

        intersectPosition   = lStart + distance * rayDirection;
        instersectNormal    = intersectPosition - ballCenter;
        if (ground){
            instersectNormal = vec3(0.0, 1.0, 0.0);
            if (length(intersectPosition.xz) > 10.0) return false;

            if (fract(intersectPosition.x) > 0.5 == fract(intersectPosition.z) > 0.5)   collisionColor = vec3(1.0, 1.0, 1.0);
            else                                                                        collisionColor = vec3(0.5, 0.5, 0.0);

        }

        endColour       += lightAt(instersectNormal, rayDirection, collisionColor);
        endColour       *= colMultiplier;
        colMultiplier   *= mix(blandColour, collisionColor, 0.7);
        rayDirection = reflect(rayDirection, instersectNormal);
        return true;
    }

void main(void) {
    vec3 cameraDir = normalize(vPosition - cameraPostion);
    vec3 intersectPosition1, intersectPosition2, intersectPosition3, dummy;
    vec3 endColour, colMultiplier;
    endColour       = vec3(0.0, 0.0, 0.0);
    colMultiplier   = vec3(1.0, 1.0, 1.0);
    if (intersectWorld(cameraPostion, cameraDir, intersectPosition1, endColour, colMultiplier)) {
        if (intersectWorld(intersectPosition1, cameraDir, intersectPosition2, endColour, colMultiplier)) {
            if (intersectWorld(intersectPosition2, cameraDir, intersectPosition3, endColour, colMultiplier)) {
                    intersectWorld(intersectPosition3, cameraDir, dummy, endColour, colMultiplier);
            }
        }
    } else endColour = vec3(0.0, 0.0, 0.0);
    gl_FragColor = vec4(endColour, 1.0);
}
</script>
<script id="x-vertex" type="x-shader">
    attribute   float   a_label;
    uniform     float   u_time;
    uniform     float   u_ratio;
    varying     vec3    vPosition;
    varying     vec3    cameraPostion;
    varying     vec4    spherePos[10];
    varying     vec3    sphereCol[10];
    #define     PI      3.14159265
    void main(void) {
        vec3 cameraTo   = vec3(0.0, 0.0, 0.0);
        vec3 up         = vec3(0.0, 1.0, 0.0);
        float cameraPersp = 5.0;

        sphereCol[1]    = vec3(0.4, 0.4, 0.4);
        sphereCol[4]    = vec3(0.8, 0.8, 0.8);
        sphereCol[2]    = vec3(0.0, 0.5, 0.5);
        sphereCol[5]    = vec3(0.9, 0.9, 0.5);
        sphereCol[6]    = vec3(0.2, 0.3, 0.5);
        sphereCol[3]    = vec3(0.1, 0.1, 0.1);
        sphereCol[7]    = vec3(0.6, 0.2, 0.2);
        sphereCol[8]    = vec3(0.9, 0.6, 0.7);
        sphereCol[9]    = vec3(0.3, 0.6, 0.3);
        sphereCol[0]    = vec3(0.4, 0.4, 0.7);
        cameraPostion   = vec3(+20.0 * sin(u_time * 0.003),              10.0 + 10.0 * sin(u_time * 0.002),      20.0 * cos(u_time * 0.001));
        spherePos[1]    = vec4( +0.0,                                   +1.0 + 0.5 * abs(sin(u_time * 0.2)),    +0.0,                                   1.0);
        spherePos[2]    = vec4( +2.0 * cos(u_time * 0.015 + PI),        +1.0,                                   +2.0 * sin(u_time * 0.015 + PI),        1.0);
        spherePos[4]    = vec4( +0.0,                                   +3.0 + 2.0 * abs(sin(u_time * 0.1)),    +0.0,                                   1.0);
        spherePos[5]    = vec4( +2.0 * cos(u_time * 0.015 + PI*0.5),    +1.0,                                   +2.0 * sin(u_time * 0.015 + PI*0.5),    1.0);
        spherePos[6]    = vec4( +2.0 * cos(u_time * 0.015 + PI*1.5),    +1.0,                                   +2.0 * sin(u_time * 0.015 + PI*1.5),    1.0);
        float sep = 1.41;
        spherePos[3]    = vec4( +3.41 * cos(u_time * 0.015),             +1.0 + sep,                            +3.41 * sin(u_time * 0.015),            1.0);
        spherePos[7]    = vec4( sep * sin(u_time * 0.015),              -sep,                                    sep * cos(u_time * 0.015),              0.0) + spherePos[3];
        spherePos[8]    = vec4( sep * sin(u_time * 0.015 + PI),         -sep,                                    sep * cos(u_time * 0.015 + PI),         0.0) + spherePos[3];
        spherePos[9]    = vec4( sep * sin(u_time * 0.015 + PI*0.5),     -sep,                                    sep * cos(u_time * 0.015 + PI*0.5),     0.0) + spherePos[3];
        spherePos[0]    = vec4( sep * sin(u_time * 0.015 + PI*1.5),     -sep,                                    sep * cos(u_time * 0.015 + PI*1.5),     0.0) + spherePos[3];

        vec3 cameraDir  = normalize(cameraTo - cameraPostion);
        vec3 cameraLeft = normalize(cross(cameraDir, up));
        vec3 cameraUp   = normalize(cross(cameraLeft, cameraDir));
        vec3 cameraCenter= cameraPostion + cameraDir * cameraPersp;
        vec3 cameraTopLeft  = cameraCenter + cameraUp + cameraLeft * u_ratio;
        vec3 cameraBotLeft  = cameraCenter - cameraUp + cameraLeft * u_ratio;
        vec3 cameraTopRight = cameraCenter + cameraUp - cameraLeft * u_ratio;
        vec3 cameraBotRight = cameraCenter - cameraUp - cameraLeft * u_ratio;

        if      (a_label == 1.0) {gl_Position = vec4(+1.0, +1.0, 0.0, 1.0); vPosition = cameraTopRight;}
        else if (a_label == 2.0) {gl_Position = vec4(-1.0, +1.0, 0.0, 1.0); vPosition = cameraTopLeft;}
        else if (a_label == 3.0) {gl_Position = vec4(+1.0, -1.0, 0.0, 1.0); vPosition = cameraBotRight;}
        else if (a_label == 4.0) {gl_Position = vec4(-1.0, -1.0, 0.0, 1.0); vPosition = cameraBotLeft;}
    }
</script>
<script>
    var canvas  = document.createElement("canvas"); document.body.appendChild(canvas);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    var gl = canvas.getContext("webgl");

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, document.getElementById("x-vertex").text);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, document.getElementById("x-fragment").text);
    gl.compileShader(fragmentShader);
    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.useProgram(shaderProgram);

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "a_label"), 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "a_label"));
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1,2,3,4]), gl.STATIC_DRAW);
    gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_ratio"), (canvas.width / canvas.height));

    var t = 0;
    function drawScene() {
        gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_time"), t++);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        window.requestAnimationFrame(drawScene);
    }
    drawScene();
</script>