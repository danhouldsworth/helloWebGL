<!--
What is aPlotPosition?
 -->
<body></body>
<script id="x-fragment" type="x-shader">
    precision highp float;
    const   vec3 lightDir   = 1.1 * normalize(vec3(1.0, 1.0, -1.0));
    const   vec3 blandColour= 1.1 * normalize(vec3(1.0, 1.0, 1.0));
    const   float ambience  = 0.5;
    const   float diffussion= 0.3;
    const   float shinyness = 0.7;
    varying vec3 vPosition;
    varying vec3 cameraPostion;
    varying vec4 spherePos[6];
    varying vec3 sphereCol[6];

    bool intersectSphere(vec4 sphere, vec3 rayStart, vec3 rayDirection, out float distance) {
        vec3    c = sphere.xyz - rayStart;
        float   b = dot(rayDirection, c);
        float   d = sphere.w + b * b - dot(c, c);
        if (d < 0.0) {
            distance = 999.0;
            return false;
        }
        distance = b - sqrt(d);
        if (distance < 0.0) {
            distance = 999.0;
            return false;
        }
        return true;

        // vec3    relSpherePos = sphere.xyz - rayStart;
        // float   b = dot(relSpherePos, rayDirection);
        // float   c2 = dot(relSpherePos, relSpherePos);
        // float   a2 = c2 - b*b; // pythag

        // if (a2 > (sphere.w * sphere.w)) {
        //     distance = 10000.0;
        //     return false;
        // }
        // float a = sqrt(a2);
        // distance = b - a;
        // if (distance < 0.0) {
        //     distance = 10000.0;
        //     return false;
        // }

        // return true;
    }

    vec3 lightAt(vec3 instersectNormal, vec3 rayDirection, vec3 color) {
        float visibleLightReflection = dot(reflect(lightDir, instersectNormal), rayDirection);
        if (visibleLightReflection < 0.0) visibleLightReflection = 0.0;
        float saturation = ambience
                + shinyness   * pow(visibleLightReflection, 50.0)
                + diffussion  * dot(lightDir, instersectNormal);
        if (saturation > 1.0){
            float overSaturation = saturation - 1.0;
            return mix(color, 2.0 * blandColour, overSaturation);
        }
        return saturation * color;
    }

    bool intersectWorld(vec3 lStart, inout vec3 rayDirection, out vec3 intersectPosition, inout vec3 endColour, inout vec3 colM) {
        float d[6], distance;
        vec3 instersectNormal, collisionColor, ballCenter;
        bool ground = false;
        bool h1 = intersectSphere(spherePos[1], lStart, rayDirection, d[1]);
        bool h2 = intersectSphere(spherePos[2], lStart, rayDirection, d[2]);
        bool h3 = intersectSphere(spherePos[3], lStart, rayDirection, d[3]);
        bool h4 = intersectSphere(spherePos[4], lStart, rayDirection, d[4]);
        bool h5 = intersectSphere(spherePos[5], lStart, rayDirection, d[5]);

        if      (h1 && d[1] < d[2] && d[1] < d[3] && d[1] < d[4] && d[1] < d[5]){distance = d[1]; collisionColor = sphereCol[1]; ballCenter = spherePos[1].xyz;}
        else if (h2 && d[2] < d[3] && d[2] < d[4] && d[2] < d[5])               {distance = d[2]; collisionColor = sphereCol[2]; ballCenter = spherePos[2].xyz;}
        else if (h3 && d[3] < d[4] && d[3] < d[5])                              {distance = d[3]; collisionColor = sphereCol[3]; ballCenter = spherePos[3].xyz;}
        else if (h4 && d[4] < d[5])                                             {distance = d[4]; collisionColor = sphereCol[4]; ballCenter = spherePos[4].xyz;}
        else if (h5)                                                            {distance = d[5]; collisionColor = sphereCol[5]; ballCenter = spherePos[5].xyz;}
        else if (rayDirection.y < 0.0)                                          {distance = (lStart.y + 2.7) / -rayDirection.y; ground = true;}
        else return false;

        intersectPosition   = lStart + distance * rayDirection;
        instersectNormal    = intersectPosition - ballCenter;
        if (ground){
            instersectNormal = vec3(0.0, 1.0, 0.0);
            if (length(intersectPosition.xz) > 10.0) return false;

            if (fract(intersectPosition.x) > 0.5 == fract(intersectPosition.z) > 0.5)   collisionColor = vec3(1.0, 1.0, 1.0);
            else                                                                        collisionColor = vec3(0.5, 0.5, 0.0);

        }

        endColour   += lightAt(instersectNormal, rayDirection, collisionColor);
        colM        *= mix(blandColour, collisionColor, 0.7);
        endColour   *= colM;
        rayDirection = reflect(rayDirection, instersectNormal);
        return true;
    }

void main(void) {
    vec3 cameraDir = normalize(vPosition - cameraPostion);
    vec3 intersectPosition1, intersectPosition2, intersectPosition3;
    vec3 endColour, colM;
    endColour               = vec3(0.0, 0.0, 0.0);
    colM                    = vec3(1.0, 1.0, 1.0);
    if (intersectWorld(cameraPostion, cameraDir, intersectPosition1, endColour, colM)) {
        if (intersectWorld(intersectPosition1, cameraDir, intersectPosition2, endColour, colM)) {
            if (intersectWorld(intersectPosition2, cameraDir, intersectPosition3, endColour, colM)) {
                intersectWorld(intersectPosition3, cameraDir, intersectPosition1, endColour, colM);
            }
        }
        gl_FragColor = vec4(endColour, 1.0);
    } else {
        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
    }
}
</script>
<script id="x-vertex" type="x-shader">
    attribute   float   a_label;
    uniform     float   u_time;
    uniform     float   u_ratio;
    varying     vec3    vPosition;
    varying     vec3    cameraPostion;
    varying     vec4    spherePos[6];
    varying     vec3    sphereCol[6];
    #define     PI      3.14159265
    void main(void) {
        vec3 cameraTo   = vec3(0.0, 0.0, 0.0);
        vec3 up         = vec3(0.0, 1.0, 0.0);
        float cameraPersp = 5.0;

        cameraPostion   = vec3(sin(u_time * 0.003) * 20.0,sin(u_time * 0.002) * 10.0 + 10.0,cos(u_time * 0.001) * 20.0);
        sphereCol[1]   = vec3(0.5, 0.5, 0.5);
        sphereCol[2]   = vec3(1.0, 1.0, 1.0);
        sphereCol[3]   = vec3(0.0, 0.0, 0.0);
        sphereCol[4]   = vec3(0.5, 0.0, 0.0);
        sphereCol[5]   = vec3(0.0, 0.5, 0.5);
        spherePos[1]   = vec4( +0.0,                         -2.0 + 0.5 * abs(sin(u_time * 0.2)),    +0.0,                       1.0);
        spherePos[2]   = vec4( +2.0 * cos(u_time * 0.03),    -1.9,                                   +2.0 * sin(u_time * 0.03),  1.0);
        spherePos[3]   = vec4( +4.0 * sin(u_time * 0.02),    -1.9,                                   +4.0 * cos(u_time * 0.02),  1.0);
        spherePos[4]   = vec4( +2.0 * sin(u_time * 0.06),    +0.5 * abs(sin(u_time * 0.2)),          +2.0 * cos(u_time * 0.06),  0.0) + spherePos[3];
        spherePos[5]   = vec4( +0.0,                         +2.0 * abs(sin(u_time * 0.1)),          +0.0,                       1.0);

        vec3 cameraDir  = normalize(cameraTo - cameraPostion);
        vec3 cameraLeft = normalize(cross(cameraDir, up));
        vec3 cameraUp   = normalize(cross(cameraLeft, cameraDir));
        vec3 cameraCenter= cameraPostion + cameraDir * cameraPersp;
        vec3 cameraTopLeft  = cameraCenter + cameraUp + cameraLeft * u_ratio;
        vec3 cameraBotLeft  = cameraCenter - cameraUp + cameraLeft * u_ratio;
        vec3 cameraTopRight = cameraCenter + cameraUp - cameraLeft * u_ratio;
        vec3 cameraBotRight = cameraCenter - cameraUp - cameraLeft * u_ratio;

        if      (a_label == 1.0) {gl_Position = vec4(+1.0, +1.0, 0.0, 1.0); vPosition = cameraTopRight;}
        else if (a_label == 2.0) {gl_Position = vec4(-1.0, +1.0, 0.0, 1.0); vPosition = cameraTopLeft;}
        else if (a_label == 3.0) {gl_Position = vec4(+1.0, -1.0, 0.0, 1.0); vPosition = cameraBotRight;}
        else if (a_label == 4.0) {gl_Position = vec4(-1.0, -1.0, 0.0, 1.0); vPosition = cameraBotLeft;}
    }
</script>
<script>
    var canvas  = document.createElement("canvas"); document.body.appendChild(canvas);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    var gl = canvas.getContext("webgl");

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, document.getElementById("x-vertex").text);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, document.getElementById("x-fragment").text);
    gl.compileShader(fragmentShader);
    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.useProgram(shaderProgram);

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "a_label"), 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "a_label"));
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1,2,3,4]), gl.STATIC_DRAW);
    gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_ratio"), (canvas.width / canvas.height));

    var t = 0;
    function drawScene() {
        gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_time"), t++);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        window.requestAnimationFrame(drawScene);
    }
    drawScene();
</script>