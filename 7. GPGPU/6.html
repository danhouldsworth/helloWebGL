<!--
What is aPlotPosition?
 -->
<body></body>
<script id="x-fragment" type="x-shader">
    precision mediump float;
    vec3 lightDir   = 1.07 * normalize(vec3(1.0, 1.0, -1.0));
    vec3 blandColour= 1.05 * normalize(vec3(1.0, 1.0, 1.0));
    float ambience  = 0.3;
    float diffussion= 0.3;
    float shinyness = 0.5;
    varying vec3 vPosition;
    varying vec3 cameraPostion;
    varying vec4 spherePos1;
    varying vec3 sphereCol1;

    bool intersectSphere(vec4 sphere, vec3 rayStart, vec3 rayDirection, out float distance) {
        vec3    c = sphere.xyz - rayStart;
        float   b = dot(rayDirection, c);
        float   d = sphere.w + b * b - dot(c, c);
        if (d < 0.0) {
            distance = 999.0;
            return false;
        }
        distance = b - sqrt(d);
        if (distance < 0.0) {
            distance = 999.0;
            return false;
        }
        return true;
    }

    vec3 lightAt(vec3 instersectNormal, vec3 rayDirection, vec3 color) {
        float visibleLightReflection = dot(reflect(lightDir, instersectNormal), rayDirection);
        if (visibleLightReflection < 0.0) visibleLightReflection = 0.0;
        float saturation = ambience
                + shinyness   * pow(visibleLightReflection, 50.0)
                + diffussion  * dot(lightDir, instersectNormal);
        if (saturation > 1.0){
            float overSaturation = saturation - 1.0;
            return mix(color, 2.0 * blandColour, overSaturation);
        }
        return saturation * color;
    }

    bool intersectWorld(vec3 lStart, inout vec3 rayDirection, out vec3 intersectPosition, inout vec3 endColour, inout vec3 colMultiplier) {
        float d[10], distance;
        vec3 instersectNormal, collisionColor, ballCenter;
        bool ground = false;
        bool h1 = intersectSphere(spherePos1, lStart, rayDirection, d[1]);
             if (h1)                                                                                                                                        {distance = d[1]; collisionColor = sphereCol1; ballCenter = spherePos1.xyz;}
        else if (rayDirection.y < 0.0)                                                                                                                      {distance = -lStart.y / rayDirection.y; ground = true;}
        // Our eye and objects are above the floor. Hence can't possibly intersect if ray going upwards
        else return false;

        intersectPosition   = lStart + distance * rayDirection;
        instersectNormal    = intersectPosition - ballCenter;
        if (ground){
            instersectNormal = vec3(0.0, 1.0, 0.0);
            if (length(intersectPosition.xz) > 10.0) return false;

            if (fract(intersectPosition.x) > 0.5 == fract(intersectPosition.z) > 0.5)   collisionColor = vec3(1.0, 1.0, 1.0);
            else                                                                        collisionColor = vec3(0.5, 0.5, 0.0);

        }

        endColour       += lightAt(instersectNormal, rayDirection, collisionColor);
        endColour       *= colMultiplier;
        colMultiplier   *= mix(blandColour, collisionColor, 0.7);
        rayDirection = reflect(rayDirection, instersectNormal);
        return true;
    }

void main(void) {
    vec3 cameraDir = normalize(vPosition - cameraPostion);
    vec3 intersectPosition1, intersectPosition2, intersectPosition3, dummy;
    vec3 endColour, colMultiplier;
    endColour       = vec3(0.0, 0.0, 0.0);
    colMultiplier   = vec3(1.0, 1.0, 1.0);
    if (intersectWorld(cameraPostion, cameraDir, intersectPosition1, endColour, colMultiplier)) {
        gl_FragColor = vec4(endColour, 1.0);
    } else {
        gl_FragColor = vec4(0.0,0.0,0.0, 1.0);
    }
}
</script>
<script id="x-vertex" type="x-shader">
    attribute   float   a_label;
    uniform     float   u_time;
    uniform     float   u_ratio;
    varying     vec3    vPosition;
    varying     vec3    cameraPostion;
    varying     vec4    spherePos1;
    varying     vec3    sphereCol1;
    #define     PI      3.14159265
    void main(void) {
        vec3 cameraTo   = vec3(0.0, 0.0, 0.0);
        vec3 up         = vec3(0.0, 1.0, 0.0);
        float cameraPersp = 5.0;

        sphereCol1    = vec3(0.4, 0.4, 0.4);
        cameraPostion   = vec3(+20.0 * sin(u_time * 0.003),              10.0 + 10.0 * sin(u_time * 0.002),      20.0 * cos(u_time * 0.001));
        spherePos1    = vec4( +0.0,                                   +1.0 + 0.5 * abs(sin(u_time * 0.2)),    +0.0,                                   1.0);

        vec3 cameraDir  = normalize(cameraTo - cameraPostion);
        vec3 cameraLeft = normalize(cross(cameraDir, up));
        vec3 cameraUp   = normalize(cross(cameraLeft, cameraDir));
        vec3 cameraCenter= cameraPostion + cameraDir * cameraPersp;
        vec3 cameraTopLeft  = cameraCenter + cameraUp + cameraLeft * u_ratio;
        vec3 cameraBotLeft  = cameraCenter - cameraUp + cameraLeft * u_ratio;
        vec3 cameraTopRight = cameraCenter + cameraUp - cameraLeft * u_ratio;
        vec3 cameraBotRight = cameraCenter - cameraUp - cameraLeft * u_ratio;

        if      (a_label == 1.0) {gl_Position = vec4(+1.0, +1.0, 0.0, 1.0); vPosition = cameraTopRight;}
        else if (a_label == 2.0) {gl_Position = vec4(-1.0, +1.0, 0.0, 1.0); vPosition = cameraTopLeft;}
        else if (a_label == 3.0) {gl_Position = vec4(+1.0, -1.0, 0.0, 1.0); vPosition = cameraBotRight;}
        else if (a_label == 4.0) {gl_Position = vec4(-1.0, -1.0, 0.0, 1.0); vPosition = cameraBotLeft;}
    }
</script>
<script>
    var canvas  = document.createElement("canvas"); document.body.appendChild(canvas);
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    var gl = canvas.getContext("webgl");

    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, document.getElementById("x-vertex").text);
    gl.compileShader(vertexShader);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, document.getElementById("x-fragment").text);
    gl.compileShader(fragmentShader);
    var shaderProgram = gl.createProgram();
    gl.attachShader(shaderProgram, vertexShader);
    gl.attachShader(shaderProgram, fragmentShader);
    gl.linkProgram(shaderProgram);
    gl.useProgram(shaderProgram);

    gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
    gl.vertexAttribPointer(gl.getAttribLocation(shaderProgram, "a_label"), 1, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(gl.getAttribLocation(shaderProgram, "a_label"));
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([1,2,3,4]), gl.STATIC_DRAW);
    gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_ratio"), (canvas.width / canvas.height));

    var t = 0;
    function drawScene() {
        gl.uniform1f(gl.getUniformLocation(shaderProgram, "u_time"), t++);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        window.requestAnimationFrame(drawScene);
    }
    drawScene();
</script>